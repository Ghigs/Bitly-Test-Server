Dependencies:
Programming language: C++
Programming environment: Xcode
External Libraries used: Libcurl which can be downloaded at https://curl.haxx.se/download.html. I did this using homebrew. If program is run through Xcode, one must link the library by selecting the Xcode project itself within the Xcode environment, then at the top of the menu clicking Build Phases, expanding the section labeled "Link Binary With Libraries", clicking the '+' at the bottom left corner of the table shown, clicking "add other" in the dialog that is raised, and then navigating the path to the library. For me this required using command+shift+g while in the finder window that pops up in order to navigate to /usr/local/cellar/curl/7.64.1/lib/libcurl.a

Major Design Decisions:
From looking at the test presented to me I saw that the major things I would need to do was create a server, be able to receive and process requests from a client, send and process requests to the bitly API, receive and parse through responses from the bitly API, and send a response to the client.
In order to do this I looked up tutorials on creating C++ servers, which the first portion of my code is heavily based on. Then when searching for how to send and receive requests from a C++ program I found that most examples required using an external library, so I installed and used the libcurl library for the purpose of sending requests to and receiving responses from the bitly API.
A very large portion of my time was spent on getting the server setup and ensuring that my requests and responses were properly formatted, and as a result, I did not realize until way too late, that I would need a JSON library in order to properly parse through responses from the bitly API. Because of this and an overall lack of time, I ended up having to use a much less effective solution: counting characters.
Almost all information gathered from bitly API responses was gathered through counting characters, then piecing together strings by adding the individual characters together. This also put severe limitations on how I could handle requests, and meant I had to make some suboptimal decisions for requests, in particular having to make a request to get each individual bitlink from the default group of a user due to a need to ensure exact formatting for character counting, making the program much slower than it might otherwise be.
The Program does not accomplish the entirety of the required goals. It gets close, but due to time constraints and a lack of JSON parsing, it admittedly falls short. The final response only returns the average clicks of the first Country Code of all of the bitlinks for the user within the last 30 days.
In addition the program functions, but is very likely to either break or return incorrect information if not used in ideal settings. I only had my own bitlinks to test which were all created in one day and only clicked from the US so variation in the length of bitlinks would utterly break most requests, and differing country codes would most likely result in incorrect output.
On the bright side however, the program does function properly as a server, properly communicates with the client and bitly API and manages to accomplish much of what is desired, although not all.

Endpoint functionality:
This server supports only one endpoint, which is the IP address of the device running this server followed by a forward slash and the bitly acces token of the User who's information is desired. The server then takes this access token and uses it to request information on the associated user, from which it acquires the default group guid which it then uses to acquire all of the bitlinks in the default group and the number of clicks per country in the last 30 days for each of the bitlinks. It then averages the clicks for the first country code listed, and returns this average to the client as plain text.

Example Request: GET 127.0.0.1:80/{AccessToken}
Example Response: Average Clicks for: US:1.083333
